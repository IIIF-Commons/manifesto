// Generated by dts-bundle-generator v9.5.1

import { AnnotationMotivation, Behavior, ExternalResourceType, IIIFResourceType, MediaType, RenderingFormat, ServiceProfile, ViewingDirection, ViewingHint } from '@iiif/vocabulary/dist-commonjs';
import { Euler, Vector3 } from 'threejs-math';

export declare class JSONLDResource {
	context: string;
	id: string;
	__jsonld: any;
	constructor(jsonld?: any);
	getProperty(name: string): any;
	/**
	A function that wraps the getProperty function, which client
	code can use if it is needed to identify when the json value of
	a property is an IRI -- Internationalized Resource Identifier
	
	If the value of the json value is a bare string, then it will be
	wrapped in a json object with the string in the property 'id',
	additionally that property will have a property 'isIRI' which will
	be true for the literal string case, otherwise false meaning the
	returned getProperty should be parsed as before.
	
	**/
	getPropertyAsObject(name: string): any;
}
export declare abstract class Transform extends JSONLDResource {
	constructor(jsonld?: any);
	isTransform: boolean;
	isRotateTransform: boolean | undefined;
	isScaleTransform: boolean | undefined;
	isTranslateTransform: boolean | undefined;
}
export declare class ManifestResource extends JSONLDResource {
	externalResource: IExternalResource;
	options: IManifestoOptions;
	constructor(jsonld: any, options?: IManifestoOptions);
	getIIIFResourceType(): IIIFResourceType;
	/**
	* returns the PropertyValue which in turn allows a language-specific string
	* encoded in the json as the "label" property
	* @example
	* var label = manifest.getLabel().getValue(); // returns the string for default locale
	*
	* @example
	* var label = manifest.getLabel().getValue(locale); // locale a string , examples
	*                                                   // would be "fr", "en-US",
	**/
	getLabel(): PropertyValue;
	getSummary(): PropertyValue;
	getDefaultLabel(): string | null;
	getMetadata(): LabelValuePair[];
	getRendering(format: RenderingFormat): Rendering | null;
	getRenderings(): Rendering[];
	getRequiredStatement(): LabelValuePair | null;
	getService(profile: ServiceProfile): Service | null;
	getServices(): Service[];
	getThumbnail(): Thumbnail | null;
	isAnnotation(): boolean;
	isCanvas(): boolean;
	isCollection(): boolean;
	isManifest(): boolean;
	isRange(): boolean;
	isScene(): boolean;
	isSequence(): boolean;
}
export declare class Resource extends ManifestResource {
	index: number;
	constructor(jsonld?: any, options?: IManifestoOptions);
	getFormat(): MediaType | null;
	getResources(): Annotation[];
	getType(): ExternalResourceType | null;
	getWidth(): number;
	getHeight(): number;
	getMaxWidth(): number;
	getMaxHeight(): number | null;
}
export declare class IIIFResource extends ManifestResource {
	defaultTree: TreeNode;
	index: number;
	isLoaded: boolean;
	parentCollection: Collection;
	parentLabel: string;
	constructor(jsonld?: any, options?: IManifestoOptions);
	/**
	 * @deprecated
	 */
	getAttribution(): PropertyValue;
	getDescription(): PropertyValue;
	getHomepage(): string | null;
	getIIIFResourceType(): IIIFResourceType;
	getLogo(): string | null;
	getLicense(): string | null;
	getNavDate(): Date;
	getRelated(): any;
	getSeeAlso(): any;
	getTrackingLabel(): string;
	getDefaultTree(): TreeNode;
	getRequiredStatement(): LabelValuePair | null;
	isCollection(): boolean;
	isManifest(): boolean;
	load(): Promise<IIIFResource>;
}
/**
	Developer note: This implementation does not strictly adhere
	to the description of SpecificResource in the Web Annotation Model
	document https://www.w3.org/TR/annotation-model/
	section 4 : https://www.w3.org/TR/annotation-model/#specific-resources
	
	The getTransform() method returning an Array of 3D Transfom resources, is
	an extension of SpecificResource beyond the web annotation model.
*/
export declare class SpecificResource extends ManifestResource {
	isAnnotationBody: boolean;
	isSpecificResource: boolean;
	constructor(jsonld: any, options?: IManifestoOptions);
	getSource(): object | AnnotationBody;
	get Source(): object | AnnotationBody;
	getSelector(): PointSelector | null;
	get Selector(): PointSelector | null;
	getTransform(): Transform[];
	get Transform(): Transform[];
}
/**
With the 3D extensions to the IIIF Presentation API the name of this
class is misleading, but for now is being retained for the sake backward
compatibility with earlier manifesto code and tests.

The 3D extensions allow that the body property of an annotation can be
a light, camera, or model, or a SpecificResource object wrapping a light, camera,
or model.
**/
export declare class AnnotationBody extends ManifestResource {
	constructor(jsonld?: any, options?: IManifestoOptions);
	isAnnotationBody: boolean;
	isSpecificResource: boolean;
	getFormat(): MediaType | null;
	getType(): ExternalResourceType | null;
	getWidth(): number;
	getHeight(): number;
	isModel: boolean;
	isLight: boolean;
	isCamera: boolean;
}
export declare class Light extends AnnotationBody {
	constructor(jsonld?: any, options?: IManifestoOptions);
	get isAmbientLight(): boolean;
	get isDirectionalLight(): boolean;
	get isSpotLight(): boolean;
	getColor(): Color;
	get Color(): Color;
	/**
	* The implementation of the intensity is based on
	* {@link https://github.com/IIIF/3d/blob/main/temp-draft-4.md | temp-draft-4.md }
	* and the example 3D manifests
	* {@link https://github.com/IIIF/3d/tree/main/manifests/3_lights | lights }
	* on 24 Mar 2024. The intensity property in the manifest is an object
	* with declared type 'Value', a numeric property named 'value' and a
	* property named unit . This implementation will only work with a unit == 'relative'
	* and it will be assumed that a relative unit value of 1.0 corresponds to the
	* brightest light source a rendering engine supports.
	*
	* This code will implement a default intensity of 1.0
	**/
	getIntensity(): number;
	get Intensity(): number;
	/**
	* As defined in the temp-draft-4.md (
	* https://github.com/IIIF/3d/blob/main/temp-draft-4.md#lights ; 12 May 2024)
	* this quantity is the half-angle of the cone of the spotlight.
	*
	* The inconsistency between this definition of the angle and the definition of
	* fieldOfView for PerspectiveCamera (where the property value defines the full angle) has
	* already been noted: https://github.com/IIIF/api/issues/2284
	*
	* provisional decision is to return undefined in case that this property
	* is accessed in a light that is not a spotlight
	*
	*
	* @returns number
	
	**/
	getAngle(): number | undefined;
	get Angle(): number | undefined;
	/**
	* @return : if not null, is either a PointSelector, or an object
	* with an id matching the id of an Annotation instance.
	**/
	getLookAt(): object | PointSelector | null;
	get LookAt(): object | null;
}
export declare class Camera extends AnnotationBody {
	constructor(jsonld?: any, options?: IManifestoOptions);
	get isPerspectiveCamera(): boolean;
	get isOrthographicCamera(): boolean;
	/**
	@returns full angular size of perspective viewport in vertical direction.
	Angular unit is degrees
	**/
	getFieldOfView(): number | undefined;
	/**
	Full angular size of perspective viewport in vertical direction.
	Angular unit is degrees
	**/
	get FieldOfView(): number | undefined;
	/**
	@returns full linear size of orthographic viewport in vertical direction.
	linear unit is Scene global unit of measure
	
	Name of this property was originally Height, has been changed
	at this revision to ViewHeight:
	See issues at https://github.com/IIIF/api/issues/2289
	**/
	getViewHeight(): number | undefined;
	get ViewHeight(): number | undefined;
	/**
	* @return : if not null, is either a PointSelector, or an object
	* with an id matching the id of an Annotation instance.
	**/
	getLookAt(): object | PointSelector | null;
	get LookAt(): object | null;
}
export declare class AnnotationBodyParser {
	static BuildFromJson(jsonld: any, options?: IManifestoOptions): AnnotationBody;
}
export declare class Annotation extends ManifestResource {
	constructor(jsonld: any, options: IManifestoOptions);
	/**
	In spite of its name, this method returns an array of objects, each of which
	represents a potential body annotations
	
	@see{ https://iiif.io/api/cookbook/recipe/0033-choice/ }
	**/
	getBody(): (AnnotationBody | SpecificResource)[];
	get Body(): (SpecificResource | AnnotationBody)[];
	/**
	auxiliary function to getBody; intended to hande an object that has an element items
	which is a array of annotation- body-like objects. This : https://iiif.io/api/cookbook/recipe/0033-choice/
	seems to be the use case for this
	**/
	private parseBodiesFromItemsList;
	/**
	auxiliary function to parseBodiesFromItemsList and getBody, this is the last
	step on recursively going through collections of bodies.
	**/
	private parseSingletonBody;
	/**
	Developer Note: 8 April 2024
	getBody3D function was developed in the early stages of the 3D API Feb-March 2024
	as alternative to the existing Annotation getBody function, but the signature for
	getBody3D was chosen to be a single object instance, not an array.
	
	At this stage, the merging of the 2D API anf the draft 3D API has been completed, so
	3D applications can use the getBody() function to retrieve the body of an Annotation intended
	to target a scene. For compatibily the return value of the function is still an
	array.
	
	3D clients using getBody are responsible for choosing the appropriate instance from the
	returned array. In most cases this will be the sole 0th element.
	**/
	getBody3D(): (AnnotationBody | SpecificResource);
	getMotivation(): AnnotationMotivation | null;
	getOn(): string;
	getTarget(): any;
	get Target(): any;
	getResource(): Resource;
	/**
	*    A 3D point coordinate object for the location of an Annotation
	*    to satisfy the requirements of the lookAt property of camera and
	*    spotlight resources, according to the draft v4 API as of April 1 2024
	*
	*    Is the position of the point for a target which is a SpecificResource with
	*    a PointSelector
	*    Otherwise, for example when the annotation target is an entire Scene, the
	*    location for lookAt is the origin (0,0,0)
	**/
	get LookAtLocation(): Vector3;
}
export declare class AnnotationList extends JSONLDResource {
	options: IManifestoOptions;
	label: string;
	isLoaded: boolean;
	constructor(label: any, jsonld?: any, options?: IManifestoOptions);
	getIIIFResourceType(): IIIFResourceType;
	getLabel(): string;
	getResources(): Annotation[];
	load(): Promise<AnnotationList>;
}
export declare class AnnotationPage extends ManifestResource {
	constructor(jsonld: any, options: IManifestoOptions);
	getItems(): Annotation[];
}
export declare class Canvas extends Resource {
	ranges: Range$1[];
	constructor(jsonld?: any, options?: IManifestoOptions);
	getCanonicalImageUri(w?: number): string;
	getMaxDimensions(): Size | null;
	getContent(): Annotation[];
	getDuration(): number | null;
	getImages(): Annotation[];
	getIndex(): number;
	getOtherContent(): Promise<AnnotationList[]>;
	getWidth(): number;
	getHeight(): number;
	getViewingHint(): ViewingHint | null;
	get imageResources(): any;
	get resourceAnnotations(): any;
	/**
	 * Returns a given resource Annotation, based on a contained resource or body
	 * id
	 */
	resourceAnnotation(id: any): any;
	/**
	 * Returns the fragment placement values if a resourceAnnotation is placed on
	 * a canvas somewhere besides the full extent
	 */
	onFragment(id: any): any;
	get iiifImageResources(): any;
	get imageServiceIds(): any;
	get aspectRatio(): number;
}
export declare class Collection extends IIIFResource {
	items: IIIFResource[];
	private _collections;
	private _manifests;
	constructor(jsonld: any, options: IManifestoOptions);
	getCollections(): Collection[];
	getManifests(): Manifest[];
	getCollectionByIndex(collectionIndex: number): Promise<Collection>;
	getManifestByIndex(manifestIndex: number): Promise<Manifest>;
	getTotalCollections(): number;
	getTotalManifests(): number;
	getTotalItems(): number;
	getViewingDirection(): ViewingDirection;
	/**
	 * Note: this only will return the first behavior as per the manifesto convention
	 * IIIF v3 supports multiple behaviors
	 */
	getBehavior(): Behavior | null;
	getViewingHint(): ViewingHint | null;
	/**
	 * Get a tree of sub collections and manifests, using each child manifest's first 'top' range.
	 */
	getDefaultTree(): TreeNode;
	private _parseManifests;
	private _parseCollections;
}
export declare class Duration {
	start: number;
	end: number;
	constructor(start: number, end: number);
	getLength(): number;
}
export interface IAccessToken {
	accessToken: string;
	error: string;
	errorDescription: string;
	expiresIn: number;
	tokenType: string;
}
export interface IExternalImageResourceData extends IExternalResourceData {
	width: number;
	height: number;
}
export interface IExternalResource {
	authAPIVersion: number;
	authHoldingPage: any;
	clickThroughService: Service | null;
	data: IExternalResourceData;
	dataUri: string | null;
	error: any;
	externalService: Service | null;
	getData(accessToken?: IAccessToken): Promise<IExternalResource>;
	hasServiceDescriptor(): boolean;
	height: number;
	index: number;
	isAccessControlled(): boolean;
	isResponseHandled: boolean;
	kioskService: Service | null;
	loginService: Service | null;
	logoutService: Service | null;
	options?: IManifestoOptions;
	restrictedService: Service | null;
	status: number;
	tokenService: Service | null;
	width: number;
}
export interface IExternalResourceData {
	contentLocation: string;
	hasServiceDescriptor: boolean;
	id: string;
	index: number;
	profile: string | any[];
}
export interface IExternalResourceOptions {
	authApiVersion: number;
}
export interface IManifestoOptions {
	defaultLabel: string;
	index?: number;
	locale: string;
	navDate?: Date;
	pessimisticAccessControl: boolean;
	resource: IIIFResource;
}
export declare class LabelValuePair {
	label: PropertyValue | null;
	value: PropertyValue | null;
	defaultLocale: string;
	resource: any;
	constructor(defaultLocale: string);
	parse(resource: any): void;
	getLabel(locale?: string | string[]): string | null;
	setLabel(value: string): void;
	getValue(locale?: string | string[], joinWith?: string): string | null;
	getValues(locale?: string | string[]): Array<string | null>;
	setValue(value: string): void;
}
/** @deprecated Use LocalizedValue instead */
export interface Language {
	value: string;
	locale: string;
}
/** @deprecated Use PropertyValue instead */
export declare class LanguageMap extends Array<Language> {
	/** @deprecated Use the `PropertyValue#getValue` instance method instead */
	static getValue(languageCollection: LanguageMap, locale?: string): string | null;
	/** @deprecated Use the `PropertyValue#getValues` instance method instead */
	static getValues(languageCollection: LanguageMap, locale?: string): Array<string | null>;
}
/** Utility class to hold one or more values with their associated (optional) locale */
export declare class LocalizedValue implements Language {
	_value: string | string[];
	_locale?: string;
	_defaultLocale: string;
	/** Parse a localized value from a IIIF v2 property value
	 *
	 * @param {string | string[] | object | object[]} rawVal value from IIIF resource
	 * @param {string | undefined} defaultLocale deprecated: defaultLocale the default locale to use for this value
	 */
	static parseV2Value(rawVal: any, defaultLocale?: string): LocalizedValue | null;
	constructor(value: string | string[], locale?: string, defaultLocale?: string);
	/*** @deprecated Use PropertyValue#getValue instead */
	get value(): string;
	/*** @deprecated Don't use, only used for backwards compatibility reasons */
	get locale(): string;
	addValue(value: string | string[]): void;
}
/***
 * Holds a collection of values and their (optional) languages and allows
 * language-based value retrieval as per the algorithm described in
 * https://iiif.io/api/presentation/2.1/#language-of-property-values
 */
export declare class PropertyValue extends Array<LocalizedValue> {
	_defaultLocale?: string;
	static parse(rawVal: any, defaultLocale?: string): PropertyValue;
	constructor(values?: LocalizedValue[], defaultLocale?: string);
	/*** Try to find the available locale that best fit's the user's preferences. */
	private getSuitableLocale;
	/**
	 * Set the value(s) for a given locale.
	 *
	 * If there's an existing locale that matches the given locale, it will be updated.
	 *
	 * @param locale Locale to set the value for
	 * @param value value to set
	 */
	setValue(value: string | string[], locale?: string): void;
	/**
	 * Get a value in the most suitable locale.
	 *
	 * @param {string | string[] | undefined} locales Desired locale, can be a list of
	 * locales sorted by descending priority.
	 * @param {string | undefined} joinWith String to join multiple available values by,
	 * if undefined only the first available value will be returned
	 * @returns the first value in the most suitable locale or null if none could be found
	 */
	getValue(locales?: string | string[], joinWith?: string): string | null;
	/**
	 * Get all values available in the most suitable locale.
	 *
	 * @param {string | string[]} userLocales Desired locale, can be a list of
	 * locales sorted by descending priority.
	 * @returns the values for the most suitable locale, empty if none could be found
	 */
	getValues(userLocales?: string | string[]): string[];
}
/**
* @remarks Scenes are conveniently retrieved from a Manifest by iterating through
* Sequence in the Manifest, inner loop the Scenes in each sequence
* @see {@link Sequence }
*
* @example
* var manifest: Manifest;
* function doSomethingWithScene(scene:Scene)...
* ...
* foreach(var seq:Sequence of manifest.getSequences()
*   foreach(var scene : Scene of seq.getScenes()
*     doSomethingWithScene(scene);
**/
export declare class Manifest extends IIIFResource {
	index: number;
	private _allRanges;
	items: Sequence[];
	private _topRanges;
	constructor(jsonld?: any, options?: IManifestoOptions);
	/** @deprecated Use getAccompanyingCanvas instead */
	getPosterCanvas(): Canvas | null;
	getAccompanyingCanvas(): Canvas | null;
	getBehavior(): Behavior | null;
	getDefaultTree(): TreeNode;
	private _getTopRanges;
	getTopRanges(): Range$1[];
	private _getRangeById;
	private _parseRanges;
	getAllRanges(): Range$1[];
	getRangeById(id: string): Range$1 | null;
	getRangeByPath(path: string): Range$1 | null;
	/**
	* @returns Array of Sequence instances
	**/
	getSequences(): Sequence[];
	getSequenceByIndex(sequenceIndex: number): Sequence;
	getTotalSequences(): number;
	getManifestType(): ManifestType;
	isMultiSequence(): boolean;
	isPagingEnabled(): boolean;
	getViewingDirection(): ViewingDirection | null;
	getViewingHint(): ViewingHint | null;
	_annotationIdMap: any;
	/**
	* Developer Note: The concept of the "id map" appear in the
	* JSON-LD specification https://www.w3.org/TR/json-ld11/#dfn-id-map
	* This functionality may be available as well in the 'nodeMap' code of the
	* digitalbazaar/jsonld library
	*
	* this very simplified version just returns a mao of id -> Annotation nodes
	* in manifest
	*
	* THe annotationIdMap is a Javascript object whose property names are
	* IRI (id values) and property values are instances of the Annotation class
	**/
	get annotationIdMap(): Object;
}
export declare enum ManifestType {
	EMPTY = "",
	MANUSCRIPT = "manuscript",
	MONOGRAPH = "monograph"
}
export declare class PointSelector extends JSONLDResource {
	isPointSelector: boolean;
	constructor(jsonld: any);
	/**
	@returns the 3D coordinates of the point as a Vector3 instance.
	**/
	getLocation(): Vector3;
	/**
	@returns the 3D coordinates of the point as a Vector3 instance.
	**/
	get Location(): Vector3;
}
declare class Range$1 extends ManifestResource {
	private _ranges;
	canvases: string[] | null;
	items: ManifestResource[];
	parentRange: Range$1 | undefined;
	path: string;
	treeNode: TreeNode;
	constructor(jsonld?: any, options?: IManifestoOptions);
	getCanvasIds(): string[];
	getDuration(): Duration | undefined;
	getRanges(): Range$1[];
	getBehavior(): Behavior | null;
	getViewingDirection(): ViewingDirection | null;
	getViewingHint(): ViewingHint | null;
	getTree(treeRoot: TreeNode): TreeNode;
	spansTime(time: number): boolean;
	private _parseTreeNode;
}
export declare class Rendering extends ManifestResource {
	constructor(jsonld?: any, options?: IManifestoOptions);
	getFormat(): RenderingFormat;
}
export declare class Scene extends ManifestResource {
	constructor(jsonld: any, options: IManifestoOptions);
	getContent(): Annotation[];
	get Content(): Annotation[];
	getAnnotationById(searchId: string): Annotation | null;
	getBackgroundColor(): Color | null;
}
export declare class Sequence extends ManifestResource {
	items: Canvas[];
	private _thumbnails;
	constructor(jsonld?: any, options?: IManifestoOptions);
	getCanvases(): Canvas[];
	getCanvasById(id: string): Canvas | null;
	getCanvasByIndex(canvasIndex: number): any;
	getCanvasIndexById(id: string): number | null;
	getCanvasIndexByLabel(label: string, foliated?: boolean): number;
	getLastCanvasLabel(alphanumeric?: boolean): string;
	getLastPageIndex(): number;
	getNextPageIndex(canvasIndex: number, pagingEnabled?: boolean): number;
	getPagedIndices(canvasIndex: number, pagingEnabled?: boolean): number[];
	getPrevPageIndex(canvasIndex: number, pagingEnabled?: boolean): number;
	/**
	* @returns Array of Scene instances in the Sequence
	**/
	getScenes(): Scene[];
	getStartCanvasIndex(): number;
	getThumbs(width: number, height?: number): Thumb[];
	getThumbnails(): Thumbnail[];
	getStartCanvas(): string;
	getTotalCanvases(): number;
	getViewingDirection(): ViewingDirection | null;
	getViewingHint(): ViewingHint | null;
	isCanvasIndexOutOfRange(canvasIndex: number): boolean;
	isFirstCanvas(canvasIndex: number): boolean;
	isLastCanvas(canvasIndex: number): boolean;
	isMultiCanvas(): boolean;
	isPagingEnabled(): boolean;
	isTotalCanvasesEven(): boolean;
}
export declare class Deserialiser {
	static parse(manifest: any, options?: IManifestoOptions): IIIFResource | null;
	static parseJson(json: any, options?: IManifestoOptions): IIIFResource | null;
	static parseCollection(json: any, options?: IManifestoOptions): Collection;
	static parseCollections(collection: Collection, options?: IManifestoOptions): void;
	static parseManifest(json: any, options?: IManifestoOptions): Manifest;
	static parseManifests(collection: Collection, options?: IManifestoOptions): void;
	static parseItem(json: any, options?: IManifestoOptions): IIIFResource | null;
	static parseItems(collection: Collection, options?: IManifestoOptions): void;
}
export declare class Service extends ManifestResource {
	constructor(jsonld?: any, options?: IManifestoOptions);
	getProfile(): ServiceProfile;
	getConfirmLabel(): string | null;
	getDescription(): string | null;
	getFailureDescription(): string | null;
	getFailureHeader(): string | null;
	getHeader(): string | null;
	getServiceLabel(): string | null;
	getInfoUri(): string;
}
export declare class Size {
	width: number;
	height: number;
	constructor(width: number, height: number);
}
export declare enum StatusCode {
	AUTHORIZATION_FAILED = 1,
	FORBIDDEN = 2,
	INTERNAL_SERVER_ERROR = 3,
	RESTRICTED = 4
}
export declare class Thumb {
	data: any;
	index: number;
	uri: string;
	label: string;
	width: number;
	height: number;
	visible: boolean;
	viewingHint: ViewingHint | null;
	constructor(width: number, canvas: Canvas);
}
export declare class Thumbnail extends Resource {
	constructor(jsonld: any, options: IManifestoOptions);
}
export declare class TranslateTransform extends Transform {
	constructor(jsonld?: any);
	getTranslation(): object;
}
export declare class TransformParser {
	static BuildFromJson(jsonld: any): Transform;
}
export declare class TreeNode {
	data: any;
	nodes: TreeNode[];
	selected: boolean;
	expanded: boolean;
	id: string;
	label: string;
	navDate: Date;
	parentNode: TreeNode;
	constructor(label?: string, data?: any);
	addNode(node: TreeNode): void;
	isCollection(): boolean;
	isManifest(): boolean;
	isRange(): boolean;
}
export declare enum TreeNodeType {
	COLLECTION = "collection",
	MANIFEST = "manifest",
	RANGE = "range"
}
export declare class Utils {
	static getMediaType(type: string): MediaType;
	static getImageQuality(profile: ServiceProfile): string;
	static getInexactLocale(locale: string): string;
	static getLocalisedValue(resource: any, locale: string): string | null;
	static generateTreeNodeIds(treeNode: TreeNode, index?: number): void;
	static normaliseType(type: string): string;
	static normaliseUrl(url: string): string;
	static normalisedUrlsMatch(url1: string, url2: string): boolean;
	static isImageProfile(profile: ServiceProfile): boolean;
	static isImageServiceType(type: string | null): boolean;
	static isLevel0ImageProfile(profile: ServiceProfile): boolean;
	static isLevel1ImageProfile(profile: ServiceProfile): boolean;
	static isLevel2ImageProfile(profile: ServiceProfile): boolean;
	static parseManifest(manifest: any, options?: IManifestoOptions | undefined): IIIFResource | null;
	static checkStatus(response: any): any;
	static loadManifest(url: string): Promise<any>;
	static loadExternalResourcesAuth1(resources: IExternalResource[], openContentProviderInteraction: (service: Service) => any, openTokenService: (resource: IExternalResource, tokenService: Service) => Promise<any>, getStoredAccessToken: (resource: IExternalResource) => Promise<IAccessToken | null>, userInteractedWithContentProvider: (contentProviderInteraction: any) => Promise<any>, getContentProviderInteraction: (resource: IExternalResource, service: Service) => Promise<any>, handleMovedTemporarily: (resource: IExternalResource) => Promise<any>, showOutOfOptionsMessages: (resource: IExternalResource, service: Service) => void): Promise<IExternalResource[]>;
	static loadExternalResourceAuth1(resource: IExternalResource, openContentProviderInteraction: (service: Service) => any, openTokenService: (resource: IExternalResource, tokenService: Service) => Promise<void>, getStoredAccessToken: (resource: IExternalResource) => Promise<IAccessToken | null>, userInteractedWithContentProvider: (contentProviderInteraction: any) => Promise<any>, getContentProviderInteraction: (resource: IExternalResource, service: Service) => Promise<any>, handleMovedTemporarily: (resource: IExternalResource) => Promise<any>, showOutOfOptionsMessages: (resource: IExternalResource, service: Service) => void): Promise<IExternalResource>;
	static doAuthChain(resource: IExternalResource, openContentProviderInteraction: (service: Service) => any, openTokenService: (resource: IExternalResource, tokenService: Service) => Promise<any>, userInteractedWithContentProvider: (contentProviderInteraction: any) => Promise<any>, getContentProviderInteraction: (resource: IExternalResource, service: Service) => Promise<any>, handleMovedTemporarily: (resource: IExternalResource) => Promise<any>, showOutOfOptionsMessages: (resource: IExternalResource, service: Service) => void): Promise<IExternalResource | void>;
	static attemptResourceWithToken(resource: IExternalResource, openTokenService: (resource: IExternalResource, tokenService: Service) => Promise<any>, authService: Service): Promise<IExternalResource | void>;
	static loadExternalResourcesAuth09(resources: IExternalResource[], tokenStorageStrategy: string, clickThrough: (resource: IExternalResource) => Promise<any>, restricted: (resource: IExternalResource) => Promise<any>, login: (resource: IExternalResource) => Promise<any>, getAccessToken: (resource: IExternalResource, rejectOnError: boolean) => Promise<IAccessToken>, storeAccessToken: (resource: IExternalResource, token: IAccessToken, tokenStorageStrategy: string) => Promise<any>, getStoredAccessToken: (resource: IExternalResource, tokenStorageStrategy: string) => Promise<IAccessToken>, handleResourceResponse: (resource: IExternalResource) => Promise<any>, options?: IManifestoOptions): Promise<IExternalResource[]>;
	static loadExternalResourceAuth09(resource: IExternalResource, tokenStorageStrategy: string, clickThrough: (resource: IExternalResource) => Promise<any>, restricted: (resource: IExternalResource) => Promise<any>, login: (resource: IExternalResource) => Promise<any>, getAccessToken: (resource: IExternalResource, rejectOnError: boolean) => Promise<IAccessToken>, storeAccessToken: (resource: IExternalResource, token: IAccessToken, tokenStorageStrategy: string) => Promise<any>, getStoredAccessToken: (resource: IExternalResource, tokenStorageStrategy: string) => Promise<IAccessToken>, handleResourceResponse: (resource: IExternalResource) => Promise<any>, options?: IManifestoOptions): Promise<IExternalResource>;
	static createError(name: StatusCode, message: string): Error;
	static createAuthorizationFailedError(): Error;
	static createRestrictedError(): Error;
	static createInternalServerError(message: string): Error;
	static authorize(resource: IExternalResource, tokenStorageStrategy: string, clickThrough: (resource: IExternalResource) => Promise<any>, restricted: (resource: IExternalResource) => Promise<any>, login: (resource: IExternalResource) => Promise<any>, getAccessToken: (resource: IExternalResource, rejectOnError: boolean) => Promise<IAccessToken>, storeAccessToken: (resource: IExternalResource, token: IAccessToken, tokenStorageStrategy: string) => Promise<any>, getStoredAccessToken: (resource: IExternalResource, tokenStorageStrategy: string) => Promise<IAccessToken>): Promise<IExternalResource>;
	private static showAuthInteraction;
	static getService(resource: any, profile: ServiceProfile): Service | null;
	static getResourceById(parentResource: JSONLDResource, id: string): JSONLDResource;
	/**
	 * Does a depth first traversal of an Object, returning an Object that
	 * matches provided k and v arguments
	 * @example Utils.traverseAndFind({foo: 'bar'}, 'foo', 'bar')
	 */
	static traverseAndFind(object: any, k: string, v: string): object | undefined;
	static getServices(resource: any, { onlyService, onlyServices, skipParentResources }?: {
		onlyServices?: boolean;
		skipParentResources?: boolean;
		onlyService?: boolean;
	}): Service[];
	static getTemporalComponent(target: string): number[] | null;
}
export declare class RotateTransform extends Transform {
	constructor(jsonld?: any);
	getRotation(): object;
}
export declare class ScaleTransform extends Transform {
	constructor(jsonld?: any);
	getScale(): object;
}
/**
 * class structure with red, green, blue values in 0-255 range
 * Uses the {@link  https://www.npmjs.com/package.color-string | color-string }
 * library for conversion from and to string representations of color.
**/
export declare class Color {
	/**
	* @param cssTerm - hex representtion of color as used in CSS. Ex "#FF0000" as red
	* @returns Color instance.
	**/
	static fromCSS(cssTerm: string): Color;
	/**
	* @param rgbValue - Array of three 0-255 integers for r,g,b value. Ex: [255.0,0] for red
	**/
	constructor(rgbValue: number[]);
	/**
	* @returns Array of 3 integers in range 0-255
	**/
	value: number[];
	/**
	* @return 0 to 255 value of red color component
	**/
	get red(): number;
	/**
	* @return 0 to 255 value of green color component
	**/
	get green(): number;
	/**
	* @return 0 to 255 value of blue color component
	**/
	get blue(): number;
	/**
	* @returns  hex string (as for CSS ) representation of r,g,b components
	**/
	get CSS(): string;
}
/**
* performs the calculation required for the lookAt
* property of a camera resource. Determines the
* required angles of two rotations, the first about
* the x axis and the second about the y axis, which will
* rotate the default camera direction (0,0,-1) into the
* direction of the input arguments
*
* Result of calculation is returned as a instance of EulerAngle from the
* threejs-math library. The "axes order" of the EulerAngle is "YXZ": The
* three-js library uses body-fixed axes to represent EulerAngles, which reverse
* the ordering of the "relative rotation" algorithm described in the
* draft 3d api.

* @param direction A vector interpreted as a direction. Client code
*        responsible for not passing a 0-length vector, else a

*
* @returns threejs-math.EulerAngle instance
**/
export declare function cameraRelativeRotation(direction: Vector3): Euler;
export declare function lightRelativeRotation(direction: Vector3): Euler;
/**
Initiates downloading an IIIF manifest json file from URL. Returns a Promise<any>
to allow subsequent processing on a successful fetch.

@param url  string containing the URL to Fetch
@returns Promise<any> The object returned through the Promise is the javascript object obtained by deserializing the json text.
**/
export declare const loadManifest: (url: string) => Promise<any>;
/**
Parses  IIIF manifest file to return a manifesto Manifest instance

@param manifest Either a string containing text of a manifest file or an javascript object obtained by deserializing by the JSON.parse function a manifest file.
@param options? TODO Not yet documented
@returns  instance of Manifest class.
**/
export declare const parseManifest: (manifest: any, options?: IManifestoOptions | undefined) => IIIFResource | null;

export {
	Range$1 as Range,
};

export as namespace manifesto;

export {};
